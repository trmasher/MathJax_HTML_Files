<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>The p-median Problem</title>

<script src="Travis_p-median_Problem_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="Travis_p-median_Problem_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="Travis_p-median_Problem_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="Travis_p-median_Problem_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="Travis_p-median_Problem_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="Travis_p-median_Problem_files/navigation-1.1/tabsets.js"></script>
<link href="Travis_p-median_Problem_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="Travis_p-median_Problem_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="fluid-row" id="header">



<h1 class="title toc-ignore">The p-median Problem</h1>

</div>


<style>
  h1.title {
    text-align: center;
    font-size: 46px;
    font-family: "Baskerville Old Face", Arial, Helvetica, sans-serif;
    color: black;
    margin-bottom: 25px;
  }

  .figure {
    position: relative;
    width: 100%;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), 0 6px 20px rgba(0, 0, 0, 0.19);
    margin: 25px 0 40px;
  }

  .container {
    position: relative;
    font-size: 16px;
    font-style: italic;
    font-family: Helvetica, "Times New Roman", Times, serif;
    width: 100%;
    margin: 0 0 15px; 
    border-style: double;
    border-width: thick;
    background-color: rgba(255, 204, 153, 0.2);
  }  
  
  h1 {
    font-family: "Baskerville Old Face", Arial, Helvetica, sans-serif;
    color: DarkBlue;
    font-size: 38px;
    text-shadow: 0 4px 8px rgba(100,100,250,.2), 0 6px 20px rgba(100, 100, 250, 0.19);
    margin: 45px 0 5px;
  }
  
  h2, h3 {
    font-family: Helvetica, "Times New Roman", Times, serif;
    color: DarkCyan;
    margin: 40px 0 5px;
  }
  
  body {
    font-size: 18px;
    font-family: Helvetica, "Times New Roman", Times, serif;
  }
  
  p {
    margin: 10px 0 35px;
  }
  
  .MathJax {
    font-size: 17px !important;
    font-family: "Times New Roman", Times, serif !important;
  }
</style>
<div id="the-statement-of-the-problem" class="section level1">
<h1>The Statement of the Problem</h1>
<p>The p-median problem is an application of linear optimization approaches with respect to a graph. Specifically, it is a facility-location model with the purpose of locating <span class="math inline">\(p\)</span> facilities (hereafter referred to as vertices or nodes) to minimize a constraint equation based on weighted average distances between demand nodes and selection location nodes.</p>
<p>
Stated more formally, given some graph <span class="math inline">\(G=(V,E)\)</span> where <span class="math display">\[V=(v_1,\ldots,v_n: n \in \Bbb N)\]</span> is a set of nodes of <span class="math inline">\(G\)</span>, each representing a demand weight, and where <span class="math display">\[E=(e_1,\ldots,e_m: m \in \Bbb N)\]</span> is a set of connected nodes of <span class="math inline">\(G\)</span>, the p-median problem seeks to find any number <span class="math inline">\(p\)</span> vertices such that the sum of the weighted distances from each vertex in <span class="math inline">\(G\)</span> to the closest facility is minimized. The lengths between each vertex and each facility is calculated by taking the absolute value of each member of <span class="math inline">\(E\)</span> that represents a successive path connection of nodes in between the two and computing their sum.
</p>
<p>
In this paper, we will be discussing how exactly this calculation is performed. Three sections will be covered:
<ul>
<li>
Rectifying the Issue of Computational Complexity
</li>
<li>
Setting up the p-median Problem as a Linear Programming Problem
</li>
<li>
Finding a Solution to a Linear Programming Problem
</li>
</ul>
</p>
</div>
<div id="rectifying-the-issue-of-computational-complexity" class="section level1">
<h1>Rectifying the Issue of Computational Complexity</h1>
<p>Unfortunately, when attempting to perform optimization calculations for this problem using a general graph, the computation time is <span class="math inline">\(\mathcal N \mathcal P\)</span>-hard. We can rectify this however by formulating the problem using a mathematical tree.</p>
<div class="figure">
<figure>
<img src="Images/rooted_binary_tree.png">
<div class="container">
A rooted, binary tree. Note that the designating any other node attached to two or fewer other vertices would once again result in a rooted, binary tree.
</figure>
</div>
<p>
Given some graph <span class="math inline">\(G=(V,E)\)</span> where <span class="math display">\[V=(v_1,\ldots,v_n: n \in \Bbb N)\]</span> is a set of nodes of <span class="math inline">\(G\)</span>, and where <span class="math display">\[E=(e_1,\ldots,e_m: m \in \Bbb N)\]</span> is a set of connected nodes of <span class="math inline">\(G\)</span>, we call the graph <span class="math inline">\(T=G\)</span> a <b>tree</b> if it is undirected, connected, and contains no cycles. From the procedures detailed in (Benkoczi et al.)<sup><a href="#section1">[i]</a></sup>, if <span class="math inline">\(T\)</span> is both <b>rooted</b> (meaning that there exists a hierarchy within the tree such that one node is considered to be at the ultimate level) and <b>binary</b> (meaning that for any ‘parent’ node, there are at most two ‘child’ nodes directly below them; taking “below” to mean “at a lower level with respect to the root hierarchy”, ‘parent’ to mean “superior to the child with respect to the hierarchy”, and ‘child’ to mean “inferior to the parent with respect to the hierarchy”), then an <span class="math inline">\(O(nlog^{p+2}n)\)</span> algorithm exists; thus, a solution to the p-median problem on <span class="math inline">\(T\)</span> can be computed in polynomial time.
</p>
<p>
If <span class="math inline">\(T\)</span> is not rooted, then it can be made to be so by arbitrarily selecting a vertex to designate as its root. If <span class="math inline">\(T\)</span> is not binary, then <span class="math inline">\(T\)</span> may be made to be binary by adding a linear number of vertices and edges to that set. Because it follows that any object that is composed of a linear function of objects that can be solved in polynomial time is itself solvable in polynomial time, then it follows that a tree <span class="math inline">\(T\)</span> which is neither rooted nor binary can also be solved in polynomial time.
</p>
<p>
Thus, because the graph <span class="math inline">\(G\)</span> for the p-median problem can be formulated as the tree <span class="math inline">\(T=G\)</span>, it follows that we can calculate a solution for the p-median problem in polynomial time.
</p>
</div>
<div id="setting-up-the-p-median-problem-as-a-linear-programming-problem" class="section level1">
<h1>Setting up the p-median Problem as a Linear Programming Problem</h1>
<p>
Now that we have established that we can find a solution to the p-median problem in polynomial time by setting up the problem as a tree, we desire to formulate the p-median problem as a linear programming problem. The form for the general linear programming problem is as follows:
<blockquote>
Minimize <span class="math display">\[f(\mathbf X) = \sum_{i=1}^n c_i x_i \tag{1}\label{eq1}\]</span> subject to <span class="math display">\[\sum_{i=1}^n a_{ij} x_i = b_j \forall \ j=1,2,\ldots,m \tag{2}\label{eq2}\]</span> and <span class="math display">\[x_i\ge 0, \forall \ i=1,2,\ldots,n \tag{3}\label{eq3}\]</span> where <span class="math display">\[a_{ij},c_i \in \Bbb R \text{, } b_j \ge 0 \text{, and } m\lt n \tag{4}\label{eq4}\]</span>
</blockquote>
<p>
We will begin by defining the terminology of bipartite graphs to make use of in subsequent calculations. Next, we will formulate the the total cost as a function of any given collection of <span class="math inline">\(p\)</span> vertices from our set of nodes; we will refer to this function as the <b>objective function</b>. Once this is done, we will use this objective function to formulate the p-median problem in the form of the general linear programming problem. We divide these procedures into three subsections.
</p>
<div id="bipartite-graphs" class="section level2">
<h2>Bipartite Graphs</h2>
<div class="figure">
<figure>
<img src="Images/bipartite_graphs.png" style="width: 100%;">
<div class="container">
An example of a bipartite graph, <span class="math inline">\(G=(V,E)\)</span>. The vertices <span class="math inline">\(V\)</span> are outlined in purple, the vertices of <span class="math inline">\(X \subset V\)</span> are filled in blue, the vertices <span class="math inline">\(Y \subset V\)</span> are filled in green, the edges <span class="math inline">\(E\)</span> are colored red, and the entire graph <span class="math inline">\(G\)</span> is shaded in grey.
</div>
</figure>
</div>
<p>
At this point, we will define the concept of bipartite graphs to make use of later. Suppose <span class="math inline">\(G=(V,E)\)</span> is a graph;; that is, <span class="math inline">\(G\)</span> is an ordered pair <span class="math inline">\(G=(V,E)\)</span> comprised of <span class="math inline">\(V\)</span>, a set of nodes or “vertices”, as well as <span class="math inline">\(E\)</span>, a set of edges or “links”. For bipartite graphs, the only (fundamental) change is that we now divide the vertex set <span class="math inline">\(V\)</span> into two disjoint and independent subsets of vertices; that is, <span class="math display">\[X,Y : X \cap Y = \emptyset \text{ and } X \cup Y = V \]</span> Furthermore, an additional restriction is placed upon each edge element: if <span class="math inline">\(e_k \in E\)</span> is any edge of <span class="math inline">\(G\)</span>, then <span class="math inline">\(e_k\)</span> connects an element in <span class="math inline">\(X\)</span> to an element in <span class="math inline">\(Y\)</span>; that is, <span class="math display">\[\text{if } e_k = (v_{e_k},v_{e_k}&#39;) \in E \text{, then } v_{e_k} \in X \iff v_{e_k}&#39; \in Y\]</span>
</p>
<div class="figure">
<figure>
<img src="Images/trees_as_bipartite_graphs.png" style="width: 100%;">
<div class="container">
An example of the above proof applied to some rooted, binary tree, <span class="math inline">\(T\)</span>. Blue nodes represent either even children of the root node “1” or the root node itself; green nodes represent odd children of the root node “1”. Numbers and lowercase letters denote vertices; capital letters denote edges.
</div>
</figure>
</div>
<p>
A property of trees is that every tree is a bipartite graph. To prove this, begin with some rooted tree <span class="math inline">\(T\)</span> (if <span class="math inline">\(T\)</span> is not rooted, any arbitrarily selected node to serve as the root may be selected). We will adopt the notation “an <b>odd</b>/<b>even</b> child” to indicate a node that is an odd/even number of levels beneath the root node with respect to the hierarchy, respectively.
</p>
<p>
Define the set <span class="math inline">\(X \subset V\)</span> to be the collection of all such nodes within <span class="math inline">\(V\)</span> that are either even children of the root node or the root node itself; define the set <span class="math inline">\(Y \subset V\)</span> to be the collection of all such nodes within <span class="math inline">\(V\)</span> that are odd children of the root node. From these definitions, we have the first established property of bipartite graphs: <span class="math display">\[X \cap Y = \emptyset \text{ and } X \cup Y = V\]</span>
</p>
<p>
Showing the additional property about edges is a simple task: consider any arbitrary edge <span class="math display">\[e_k=(v_{e_k},v_{e_k}&#39;) \in E \implies v_{e_k}, v_{e_k}&#39; \in V\]</span> Because <span class="math inline">\(T\)</span> is an acyclic graph by definition, taking the convetion that the <span class="math inline">\(0^{th}\)</span> node of <span class="math inline">\(T\)</span> refers to the root node of <span class="math inline">\(T\)</span>, it must be so that either
<ol>
<li>
<span class="math inline">\(\forall\ v_{e_k}\)</span> in the <span class="math inline">\(n^{th}\)</span> hierarchy of <span class="math inline">\(T\)</span> where <span class="math inline">\(n \in \Bbb N_0\)</span>, <span class="math inline">\(v_{e_k}\)</span> is the parent node to <span class="math inline">\(v_{e_k}&#39;\)</span> which lies in the <span class="math inline">\((n+1)^{th}\)</span> hierarchy of <span class="math inline">\(T\)</span>
</li>
<li>
<span class="math inline">\(\forall\ v_{e_k}\)</span> in the <span class="math inline">\((n+1)^{th}\)</span> hierarchy of <span class="math inline">\(T\)</span> where <span class="math inline">\(n \in \Bbb N_0\)</span>, <span class="math inline">\(v_{e_k}\)</span> is the child node to <span class="math inline">\(v_{e_k}&#39;\)</span> which lies in the <span class="math inline">\(n^{th}\)</span> hierarchy of <span class="math inline">\(T\)</span>
</li>
</ol>
For either case with <span class="math inline">\(n \ne 0\)</span>, <span class="math display">\[n \in 2\Bbb N_0 \iff (n + 1) \notin 2 \Bbb N_0\]</span> meaning that if <span class="math inline">\(v_{e_k}\)</span> is in an even hierarchy of <span class="math inline">\(T\)</span>, then <span class="math inline">\(v_{e_k}&#39;\)</span> is in an odd hierarchy of <span class="math inline">\(T\)</span>; the inverse statement holds as well. Hence, <span class="math display">\[v_{e_k} \in X \iff v_{e_k}&#39; \in Y,\ \forall\ n \in \Bbb N^*\]</span> We can extend this to include the case where <span class="math inline">\(n = 0\)</span> by seeing that <span class="math inline">\(v_{e_k}\)</span> is the root node of <span class="math inline">\(T\)</span> (and hence is included in <span class="math inline">\(X\)</span>) and that <span class="math inline">\(v_{e_k}&#39;\)</span> is in an odd hierarchy of <span class="math inline">\(T\)</span>, thus <span class="math inline">\(v_{e_k}&#39; \in Y\)</span>. The proof that <span class="math inline">\(T\)</span> is a bipartite graph follows from here.
</p>
</div>
<div id="formulating-the-objective-function" class="section level2">
<h2>Formulating the Objective Function</h2>
<p>
Let <span class="math inline">\(T=G\)</span> be as before, and let <span class="math display">\[F_p=(\mathscr f_1, \mathscr f_2, \dots,\mathscr f_p:p\leq n \in \Bbb N)\]</span> be a collection of some <span class="math inline">\(p\)</span> vertices in <span class="math inline">\(T\)</span> which represent a potential facility-location set (hereafter referred to as <i>median set</i>) for <span class="math inline">\(T\)</span>. Let <span class="math display">\[W_V = (w_{v_1}, w_{v_2}, \ldots,w_{v_n} : n \in \Bbb N)\]</span> be such that <span class="math inline">\(w_{v_i}\)</span> represents the demand weight for vertex <span class="math inline">\(v_i \in V\)</span>; similarly, define <span class="math display">\[A_E = (a_{e_1}, a_{e_2}, \ldots, a_{e_m} : m \in \Bbb N)\]</span> to be the (tree-metric) distance<sup><a href="#section2">[ii]</a></sup> between adjacent vertices such that, if <span class="math display">\[e_k=(v_{e_k},v_{e_k}&#39;)\]</span> where <span class="math inline">\(v_{e_k},v_{e_k}&#39; \in V\)</span>, then <span class="math display">\[a_{e_k} = \lVert e_k\rVert=\lVert v_{e_k} - v_{e_k}&#39; \rVert,\forall \ e_k \in E\]</span>
</p>
<p>
Let the distance between any two arbitrary vertices <span class="math inline">\(v_i,v_j \in V\)</span> be defined as the mapping <span class="math inline">\(\delta:(v_i,v_j) \mapsto \delta(v_i,v_j)\)</span>, and then define the mapping <span class="math inline">\(\psi_{F_p} : v_i \mapsto \psi_{F_p} (v_i)\)</span> to be the minimum weighted distance between vertex <span class="math inline">\(v_i\)</span> and any facility within the potential median set; that is, <span class="math display">\[\psi_{F_p} (v_i) = v_{w_i} \cdot\min_{\mathscr f_z \in F_p} \delta (v_i,\mathscr f_z)\]</span> For brevity, we will adopt the notation <span class="math inline">\(\delta (v_i,F_p)\)</span> to represent <span class="math inline">\(\min_{\mathscr f_z \in F_p} \delta (v_i, \mathscr f_z)\)</span>. Lastly, let the potential cost of locating a facility at the location <span class="math inline">\(\mathscr f_z\)</span> be defined as the mapping <span class="math inline">\(\gamma:\mathscr f_z \mapsto \gamma(\mathscr f_z)\)</span>.
</p>
<p>
We are now ready to formulate our objective function for any given potential median set: we define the mapping <span class="math inline">\(\Gamma: F_p \mapsto \Gamma(F_p)\)</span> by <span class="math display">\[\Gamma(F_p)=\sum_{\mathscr f_z \in F_p} \gamma(\mathscr f_z) +\sum_{v_i \in V} \psi_{F_p} (v_i)\]</span> to be the objective function for any given potential median set <span class="math inline">\(F_p \subseteq V\)</span>.
</p>
</div>
<div id="creating-the-general-linear-programming-problem" class="section level2">
<h2>Creating the General Linear Programming Problem</h2>
<p>Because we wish to select from any arbitrary potential median set the one for which the objective function is minimized, our goal in solving the p-median problem is to find the median set <span class="math inline">\(\mathscr F_p\)</span> such that <span class="math display">\[\mathscr F_p = \min_{F_p \subseteq V} \Gamma (F_p)\]</span> We will show that, with a few adjustments in terminology and symbology, this <span class="math inline">\(\mathscr F_p\)</span> fits the form of <span class="math inline">\(\eqref{eq1}\)</span>.</p>
<div id="rearranging-the-objective-function" class="section level3">
<h3>Rearranging the Objective Function</h3>
<p>
Let us consider just <span class="math inline">\(\Gamma (F_p)\)</span> alone: we have that our objective function is given by <span class="math display">\[\Gamma(F_p)=\sum_{\mathscr f_z \in F_p} \gamma(\mathscr f_z) +\sum_{v_i \in V} \psi_{F_p} (v_i)\]</span> We will now proceed by back-substituting our notation and mappings defined above in order to formulate the objective function in terms of given quantities. Because our next logical step is to substitute <span class="math display">\[\psi_{F_p} (v_i) \to v_{w_i} \cdot \delta (v_i,F_p)\]</span> followed by <span class="math display">\[\delta (v_i,F_p) \to \min_{\mathscr f_z \in F_p} \delta (v_i,\mathscr f_z)\]</span> we must move to formulate the minimum distance between any vertex in <span class="math inline">\(V\)</span> and any facility in the potential median set in terms of given quantities.
</p>
<p>
Two possibilities arise: for the first case, suppose the vertex in question is an element of the median set; that is, <span class="math inline">\(v_i \in F_p\)</span>. It is clear that this immediately implies <span class="math display">\[\delta (v_i,F_p) = 0\]</span>
</p>
<p>
For all other cases, we suppose that <span class="math inline">\(v_i \notin F_p\)</span>. Then, <span class="math inline">\(\forall\ \mathscr f_z \in F_p\)</span>, because <span class="math inline">\(T\)</span> is connected, there exists some set <span class="math inline">\(K \subset V\)</span> such that every element <span class="math inline">\(v_{k_r} \neq v_i \text{ and } v_{k_r} \neq \mathscr f_z\)</span> in <span class="math inline">\(K\)</span> lies on a path connecting <span class="math inline">\(v_i\)</span> to <span class="math inline">\(\mathscr f_z\)</span>; furthermore, because <span class="math inline">\(T\)</span> is acyclic, this path is <il>the</il> unique path connecting <span class="math inline">\(v_i\)</span> and <span class="math inline">\(\mathscr f_z\)</span>. Before proceeding, let the mapping <span class="math inline">\(\phi: (v_i, \mathscr f_z) \mapsto K\)</span> formally define <span class="math inline">\(K\)</span> for a given <span class="math inline">\((v_i,\mathscr f_z)\)</span> when the vertex and facility in question are ambiguous.
</p>
<p>
Let us denote the <span class="math inline">\(q\)</span> elements <span class="math inline">\(v_{k_r} \in K\)</span> to be such that <span class="math display">\[v_{k_q} = \mathscr f_z \text{ and } \forall\ v_{k_r}\ |\ r = 1,2,\ldots,q-1,\  \exists\ e_{v_{k_r}} \in E\ |\ e_{v_{k_r}} = (v_{k_r},v_{k_{{r+1}}})\]</span> Hence, each subset of vertices <span class="math inline">\(K\)</span> of <span class="math inline">\(V\)</span> defined in the above way induces a subset of edges <span class="math inline">\(\epsilon =(e_{v_{k_1}},e_{v_{k_2}},\ldots,e_{v_{k_{q-1}}}) \subset E\)</span>. As before, we define the mapping <span class="math inline">\(\Phi: K \mapsto \epsilon\)</span> to formally define <span class="math inline">\(\epsilon\)</span> for a given <span class="math inline">\(K\)</span> for a given <span class="math inline">\((v_i,\mathscr f_z)\)</span> by <span class="math display">\[\epsilon = \Phi (K) = (\Phi \circ \phi)(v_i,\mathscr f_z)\]</span> which is composed of <span class="math inline">\(q-1\)</span> elements <span class="math display">\[\epsilon_r = \Phi_r (k) = (\Phi \circ \phi)_r (v_i,\mathscr f_z)\]</span> We define one final mapping before proceeding: <span class="math inline">\(\varepsilon: (v_i,\mathscr f_z,r) \mapsto \epsilon\)</span> as <span class="math display">\[\varepsilon_r (v_i,\mathscr f_z) = (\Phi \circ \phi)_r (v_i,\mathscr f_z)= \epsilon_r\]</span> whenever <span class="math inline">\((v_i,\mathscr f_z)\)</span> is arbitrary and unambiguous.
</p>
<p>
Recall that the set <span class="math inline">\(A\)</span> is defined such that <span class="math inline">\(\forall\ a_{e_k} \in A_E,\ \exists \text{ corresponding } e_k \in E\)</span>. Hence, being careful about our notation, <span class="math inline">\(\forall\ \epsilon_r \in \epsilon \subset E,\ \exists \text{ corresponding } a_{\epsilon_r} \in A_{\epsilon} \subset A_E\)</span>. Thus, it follows that the subset <span class="math inline">\(A_{\epsilon} \subset A_E\)</span> represents the distances between each adjacent node within the set <span class="math inline">\(K \in V\)</span>, <span class="math inline">\(\forall\ v_i \in V\)</span> and <span class="math inline">\(\forall\ \mathscr f_z \in F_p\)</span>
</p>
<p>
Hence, the distance between arbitrary vertex <span class="math inline">\(v_i \in V\)</span> and arbitrary potential facility location <span class="math inline">\(\mathscr f_z \in F_p\)</span> is <span class="math display">\[\delta (v_i,\mathscr f_z) = \sum_{r=1}^{q-1} a_{\epsilon_r} = \sum_{r=1}^{q-1} \lVert \varepsilon_r (v_i,\mathscr f_z) \rVert = \sum_{r=1}^{q-1} \lVert \epsilon_r \rVert = \sum_{r=1}^{q-1} \lVert v_{\epsilon_r} - v_{\epsilon_r}&#39;\rVert\]</span> leading to <span class="math display">\[\psi_{F_p} (v_i) = v_{w_i} \cdot \delta (v_i,F_p) = v_{w_i} \cdot \min_{\mathscr f_z \in F_p} \delta (v_i,\mathscr f_z) = v_{w_i} \cdot \min_{\mathscr f_z \in F_p} \sum_{r=1}^{q-1} \lVert v_{\epsilon_r} - v_{\epsilon_r}&#39;\rVert = v_{w_i} \cdot \min_{\mathscr f_z \in F_p} \sum_{r=1}^{q-1} \lVert v_{\varepsilon_r (v_i,\mathscr f_z)} - v_{\varepsilon_r (v_i,\mathscr f_z)}&#39;\rVert\]</span> Satisfied with our notation, we will from here on out write <span class="math inline">\(\lVert v_{\varepsilon_r (v_i,\mathscr f_z)} - v_{\varepsilon_r (v_i,\mathscr f_z)}&#39;\rVert\)</span> as <span class="math inline">\(a_{\varepsilon_r (v_i,\mathscr f_z)}\)</span> and take the notational convention that <span class="math inline">\(a_{\epsilon_r} \gt 0\)</span>.Thus, <span class="math display">\[\Gamma(F_p)=\sum_{\mathscr f_z \in F_p} \gamma(\mathscr f_z) +\sum_{v_i \in V} \psi_{F_p} (v_i) = \sum_{\mathscr f_z \in F_p} \gamma (\mathscr f_z) + \sum_{v_i \in V} v_{w_i} \cdot \min_{\mathscr f_z \in F_p} \sum_{r=1}^{q-1} a_{\varepsilon_r (v_i,\mathscr f_z)}\]</span>
</p>
<p>
To proceed further, let us expand the summation for <span class="math inline">\(\mathscr f_z \in F_p\)</span>; additionally, we will denote <span class="math inline">\(f_z\)</span> to be the <span class="math inline">\(\mathscr f_z \in F_p\)</span> which minimizes the sum of the distances : <span class="math display">\[\Gamma(F_p) = [\gamma(\mathscr f_1) + \gamma(\mathscr f_2) + \ldots + \gamma(\mathscr f_p)] + [ \sum_{v_i \in V} w_{v_i} \cdot \min_{\mathscr f_z \in F_p} [a_{\varepsilon_1 (v_i,\mathscr f_z)} + a_{\varepsilon_1 (v_2,\mathscr f_z)} + \ldots + a_{\varepsilon_{q-1} (v_i,\mathscr f_z)}] ]\]</span> <span class="math display">\[=[\gamma(\mathscr f_1) + \gamma(\mathscr f_2) + \ldots + \gamma(\mathscr f_p)] + [ \sum_{v_i \in V} w_{v_i} \cdot [a_{\varepsilon_1 (v_i,f_z)} + a_{\varepsilon_1 (v_2,f_z)} + \ldots + a_{\varepsilon_{q-1} (v_i,f_z)}] ]\]</span>
</p>
<p>
A quick review of our notation used thus far:
<ul style="line-height: 1.7;">
<li>
<span class="math inline">\(G=(V,E)\)</span> is the p-median problem formulated as a graph with vertices <span class="math inline">\(V\)</span> representing demands nodes and edges <span class="math inline">\(E\)</span> representing paths between adjacent demand nodes
</li>
<li>
<span class="math inline">\(T=G\)</span> is the tree <span class="math inline">\(T\)</span> representing our topological location model
</li>
<li>
<span class="math inline">\(W_V\)</span> is the set of weights of <span class="math inline">\(V\)</span> where <span class="math inline">\(\forall\ v_i \in V,\ \exists\ w_{v_i} \in W_V\)</span> representing the weight of demand at node <span class="math inline">\(v_i\)</span>
</li>
<li>
<span class="math inline">\(A_E\)</span> is the set of norms of <span class="math inline">\(E\)</span> (with respect to the tree-metric) where <span class="math inline">\(\forall\ e_k \in E,\ \exists\ a_{e_k} \in A_E\)</span> representing the distance between the adjacent nodes <span class="math inline">\(v_{e_k}\)</span> and <span class="math inline">\(v_{e_k}&#39;\)</span> attached to edge <span class="math inline">\(e_k\)</span>
</li>
<li>
<span class="math inline">\(F_p \subset V\)</span> is some arbitrary collection of <span class="math inline">\(p\)</span> nodes selected from possible demand nodes to allocate as potential facility locations; we call this the potential median set
</li>
<li>
<span class="math inline">\(\delta (v_i,v_j)\)</span> represents the distance between any two (possibly non-adjacent) arbitrary vertices <span class="math inline">\(v_i,v_j \in V\)</span> <b>as a function of any two vertices in <span class="math inline">\(V\)</span></b>; additionally, <span class="math inline">\(\delta (v_i,F_p)\)</span> is defined to be the minimum distance between vertex <span class="math inline">\(v_i\)</span> and any facility within the potential median set
</li>
<li>
<span class="math inline">\(\psi_{F_p} (v_i) = v_{w_i} \cdot \delta (v_i,F_p)\)</span> represents the minimum weighted distance between vertex <span class="math inline">\(v_i\)</span> and any facility within the potential median set <b>as a function of potential median sets</b>
</li>
<li>
<span class="math inline">\(\gamma (f_z)\)</span> represents the potential cost of locating a facility at the location <span class="math inline">\(f_z\)</span> in the potential median set <b>as a function of facilities within a given potential median set</b>
</li>
<li>
<span class="math inline">\(\Gamma (F_p)\)</span> represents the total cost incurred given any potential median set <b>as a function of potential median sets</b>
</li>
<li>
<span class="math inline">\(\mathscr F_p\)</span> is the set of <span class="math inline">\(p\)</span> nodes selected from possible demand nodes that represents the minimized total cost incurred given a potential median set; it is the <b>minimal p-median set</b>: the solution to the p-median problem
</li>
</ul>
</p>
<p>
<p>Let <span class="math inline">\(\xi\)</span> denote the sum of all <span class="math inline">\(\varepsilon\)</span> for given <span class="math inline">\(v_i,\mathscr f_z\)</span>: <span class="math display">\[\xi (v_i,\mathscr f_z) = \sum_{r=1}^{q-1} \varepsilon_r (v_i,\mathscr f_z) \]</span> Our objective function has now become <span class="math display">\[\Gamma (F_p) = \sum_{\mathscr f_z \in F_p} \gamma (\mathscr f_z) + \sum_{v_i \in V} v_{w_i} \cdot \xi (v_i,\mathscr f_z) \]</span> Finally, because there exists a one-to-one correspondence between <span class="math inline">\(v_i \in V \text{ and } i=1,2,\cdots,n\)</span> as well as between <span class="math inline">\(\mathscr f_z \in F_p \text{ and } z=1,2,\cdots,n\)</span></p>
</div>
</div>
</div>
<div id="references" class="section level1">
<h1>References:</h1>
<p id="section1">
[i] “(PDF) A New Template for Solving p-Median Problems for Trees in Sub-Quadratic Time.” ResearchGate. Accessed April 22, 2019. <cite><a href="https://www.researchgate.net/publication/220770539_A_New_Template_for_Solving_p-Median_Problems_for_Trees_in_Sub-quadratic_Time" class="uri">https://www.researchgate.net/publication/220770539_A_New_Template_for_Solving_p-Median_Problems_for_Trees_in_Sub-quadratic_Time</a></cite>.
</p>
<p id="section2">
<p>[ii] For simplicity, by the term “tree-metric distance” here, we are meaning to say that the distance between any two nodes of <span class="math inline">\(T\)</span> is given by the “tree-path” distance described by the topology of the tree itself.</p>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "Travis_p-median_Problem_files/mathjax-local/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
