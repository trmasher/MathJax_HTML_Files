<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>The p-median Problem</title>

<script src="Travis_p-median_Problem_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="Travis_p-median_Problem_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="Travis_p-median_Problem_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="Travis_p-median_Problem_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="Travis_p-median_Problem_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="Travis_p-median_Problem_files/navigation-1.1/tabsets.js"></script>
<link href="Travis_p-median_Problem_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="Travis_p-median_Problem_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="fluid-row" id="header">



<h1 class="title toc-ignore">The p-median Problem</h1>

</div>


<style>
  h1.title {
    text-align: center;
    font-size: 46px;
    font-family: "Baskerville Old Face", Arial, Helvetica, sans-serif;
    color: black;
    margin-bottom: 25px;
  }

  .figure {
    position: relative;
    width: 100%;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2), 0 6px 20px rgba(0, 0, 0, 0.19);
    margin: 25px 0 40px;
  }

  .container {
    position: relative;
    font-size: 16px;
    font-style: italic;
    font-family: Helvetica, "Times New Roman", Times, serif;
    width: 100%;
    margin: 0 0 15px; 
    border-style: double;
    border-width: thick;
    background-color: rgba(255, 204, 153, 0.2);
  }  
  
  h1 {
    font-family: "Baskerville Old Face", Arial, Helvetica, sans-serif;
    color: DarkBlue;
    font-size: 38px;
    text-shadow: 0 4px 8px rgba(100,100,250,.2), 0 6px 20px rgba(100, 100, 250, 0.19);
    margin: 45px 0 5px;
  }
  
  h2, h3 {
    font-family: Helvetica, "Times New Roman", Times, serif;
    color: DarkCyan;
    margin: 40px 0 5px;
  }
  
  body {
    font-size: 18px;
    font-family: Helvetica, "Times New Roman", Times, serif;
  }
  
  p {
    margin: 10px 0 35px;
  }
  
  .MathJax {
    font-size: 17px !important;
    font-family: "Times New Roman", Times, serif !important;
  }
  
  .reference {
    font-size: 13px;
    font-family:"Times New Roman", Times, serif;
    margin: 10px 20px;
  }
</style>
<div id="the-statement-of-the-problem" class="section level1">
<h1>The Statement of the Problem</h1>
<p>
The p-median problem is an application of linear optimization approaches with respect to a graph. Specifically, it is a facility-location model with the purpose of locating <span class="math inline">\(p\)</span> facilities (hereafter referred to as vertices or nodes) to minimize a constraint equation based on weighted average distances between demand nodes and selection location nodes.
</p>
<p>
Stated more formally, given some graph <span class="math inline">\(G=(V,E)\)</span> where <span class="math display">\[V=(v_1,\ldots,v_n: n \in \Bbb N)\]</span> is a set of nodes of <span class="math inline">\(G\)</span>, each representing a demand weight, and where <span class="math display">\[E=(e_1,\ldots,e_m: m \in \Bbb N)\]</span> is a set of connected nodes of <span class="math inline">\(G\)</span>, the p-median problem seeks to find any number <span class="math inline">\(p\)</span> vertices such that the sum of the weighted distances from each vertex in <span class="math inline">\(G\)</span> to the closest facility is minimized. The lengths between each vertex and each facility is calculated by taking the absolute value of each member of <span class="math inline">\(E\)</span> that represents a successive path connection of nodes in between the two and computing their sum.
</p>
<p>
In this paper, we will be discussing how exactly this calculation is performed. Three sections will be covered:
<ul>
<li>
Rectifying the Issue of Computational Complexity
</li>
<li>
Setting up the p-median Problem as a Linear Programming Problem
</li>
<li>
Finding a Solution to a Linear Programming Problem
</li>
</ul>
</p>
</div>
<div id="rectifying-the-issue-of-computational-complexity" class="section level1">
<h1>Rectifying the Issue of Computational Complexity</h1>
<p>
Unfortunately, when attempting to perform optimization calculations for this problem using a general graph, the computation time is <span class="math inline">\(\mathcal N \mathcal P\)</span>-hard. We can rectify this however by formulating the problem using a mathematical tree.
</p>
<div class="figure">
<figure>
<img src="Images/rooted_binary_tree.png">
<div class="container">
A rooted, binary tree. Note that the designating any other node attached to two or fewer other vertices would once again result in a rooted, binary tree.
</figure>
</div>
<p>
Given some graph <span class="math inline">\(G=(V,E)\)</span> where <span class="math display">\[V=(v_1,\ldots,v_n: n \in \Bbb N)\]</span> is a set of nodes of <span class="math inline">\(G\)</span>, and where <span class="math display">\[E=(e_1,\ldots,e_m: m \in \Bbb N)\]</span> is a set of connected nodes of <span class="math inline">\(G\)</span>, we call the graph <span class="math inline">\(T=G\)</span> a <b>tree</b> if it is undirected, connected, and contains no cycles. From the procedures detailed in (Benkoczi et al.)<sup><a href="#section1">[i]</a></sup>, if <span class="math inline">\(T\)</span> is both <b>rooted</b> (meaning that there exists a hierarchy within the tree such that one node is considered to be at the ultimate level) and <b>binary</b> (meaning that for any ‘parent’ node, there are at most two ‘child’ nodes directly below them; taking “below” to mean “at a lower level with respect to the root hierarchy”, ‘parent’ to mean “superior to the child with respect to the hierarchy”, and ‘child’ to mean “inferior to the parent with respect to the hierarchy”), then an <span class="math inline">\(O(nlog^{p+2}n)\)</span> algorithm exists; thus, a solution to the p-median problem on <span class="math inline">\(T\)</span> can be computed in polynomial time.
</p>
<p>
If <span class="math inline">\(T\)</span> is not rooted, then it can be made to be so by arbitrarily selecting a vertex to designate as its root. If <span class="math inline">\(T\)</span> is not binary, then <span class="math inline">\(T\)</span> may be made to be binary by adding a linear number of vertices and edges to that set. Because it follows that any object that is composed of a linear function of objects that can be solved in polynomial time is itself solvable in polynomial time, then it follows that a tree <span class="math inline">\(T\)</span> which is neither rooted nor binary can also be solved in polynomial time.
</p>
<p>
Thus, because the graph <span class="math inline">\(G\)</span> for the p-median problem can be formulated as the tree <span class="math inline">\(T=G\)</span>, it follows that we can calculate a solution for the p-median problem in polynomial time.
</p>
</div>
<div id="setting-up-the-p-median-problem-as-a-linear-programming-problem" class="section level1">
<h1>Setting up the p-median Problem as a Linear Programming Problem</h1>
<p>
Now that we have established that we can find a solution to the p-median problem in polynomial time by setting up the problem as a tree, we desire to formulate the p-median problem as a linear programming problem. The form for the general linear programming problem is as follows:
<blockquote>
Minimize <span class="math display">\[f(\mathbf X) = \sum_{i=1}^n c_i x_i \tag{1}\label{eq1}\]</span> subject to <span class="math display">\[\sum_{i=1}^n a_{ij} x_i = b_j \forall \ j=1,2,\ldots,m \tag{2}\label{eq2}\]</span> and <span class="math display">\[x_i\ge 0, \forall \ i=1,2,\ldots,n \tag{3}\label{eq3}\]</span> where <span class="math display">\[a_{ij},c_i \in \Bbb R \text{, } b_j \ge 0 \text{, and } m\lt n \tag{4}\label{eq4}\]</span>
</blockquote>
</p>
<p>
We will first formulate the total cost as a function of any given collection of <span class="math inline">\(p\)</span> vertices from our set of nodes; we will refer to this function as the <b>objective function</b>. Once this is done, we will use this objective function to formulate the p-median problem in the form of the general linear programming problem. We divide these procedures into three subsections.
</p>
<div id="formulating-the-objective-function" class="section level2">
<h2>Formulating the Objective Function</h2>
<p>
Let <span class="math inline">\(T=G\)</span> be as before, and let <span class="math display">\[F_p=(\mathscr f_1, \mathscr f_2, \dots,\mathscr f_p:p\leq n \in \Bbb N)\]</span> be a collection of some <span class="math inline">\(p\)</span> vertices in <span class="math inline">\(T\)</span> which represent a potential facility-location set (hereafter referred to as <i>median set</i>) for <span class="math inline">\(T\)</span>. Let <span class="math display">\[W_V = (w_{v_1}, w_{v_2}, \ldots,w_{v_n} : n \in \Bbb N)\]</span> be such that <span class="math inline">\(w_{v_i}\)</span> represents the demand weight for vertex <span class="math inline">\(v_i \in V\)</span>; similarly, define <span class="math display">\[A_E = (a_{e_1}, a_{e_2}, \ldots, a_{e_m} : m \in \Bbb N)\]</span> to be the (tree-metric) distance<sup><a href="#section2">[ii]</a></sup> between adjacent vertices such that, if <span class="math display">\[e_k=(v_{e_k},v_{e_k}&#39;)\]</span> where <span class="math inline">\(v_{e_k},v_{e_k}&#39; \in V\)</span>, then <span class="math display">\[a_{e_k} = \lVert e_k\rVert=\lVert v_{e_k} - v_{e_k}&#39; \rVert,\forall \ e_k \in E\]</span>
</p>
<p>
Let the distance between any two arbitrary vertices <span class="math inline">\(v_i,v_j \in V\)</span> be defined as the mapping <span class="math inline">\(\delta:(v_i,v_j) \mapsto \delta(v_i,v_j)\)</span>, and then define the mapping <span class="math inline">\(\psi_{F_p} : v_i \mapsto \psi_{F_p} (v_i)\)</span> to be the minimum weighted distance between vertex <span class="math inline">\(v_i\)</span> and any facility within the potential median set; that is, <span class="math display">\[\psi_{F_p} (v_i) = w_{v_i} \cdot\min_{\mathscr f_z \in F_p} \delta (v_i,\mathscr f_z)\]</span> For brevity, we will adopt the notation <span class="math inline">\(\delta (v_i,F_p)\)</span> to represent <span class="math inline">\(\min_{\mathscr f_z \in F_p} \delta (v_i, \mathscr f_z)\)</span>. Lastly, let the potential cost of locating a facility at the location <span class="math inline">\(\mathscr f_z\)</span> be defined as the mapping <span class="math inline">\(\gamma:\mathscr f_z \mapsto \gamma(\mathscr f_z)\)</span>.
</p>
<p>
We are now ready to formulate our objective function for any given potential median set: we define the mapping <span class="math inline">\(\Gamma: F_p \mapsto \Gamma(F_p)\)</span> by <span class="math display">\[\Gamma(F_p)=\sum_{\mathscr f_z \in F_p} \gamma(\mathscr f_z) +\sum_{v_i \in V} \psi_{F_p} (v_i)\]</span> to be the objective function for any given potential median set <span class="math inline">\(F_p \subseteq V\)</span>.
</p>
</div>
<div id="creating-the-general-linear-programming-problem" class="section level2">
<h2>Creating the General Linear Programming Problem</h2>
<p>
Because we wish to select from any arbitrary potential median set the one for which the objective function is minimized, our goal in solving the p-median problem is to find the median set <span class="math inline">\(\mathscr F_p\)</span> such that <span class="math display">\[\mathscr F_p = \min_{F_p \subseteq V} \Gamma (F_p)\]</span> We will show that, with a few adjustments in terminology and symbology, this <span class="math inline">\(\mathscr F_p\)</span> fits the form of <span class="math inline">\(\eqref{eq1}\)</span>.
</p>
<p>
Before now, we have not really paid any consideration towards what it is precisely that we are attempting to minimize mathematically; that is to say, although we are aware that our goal is to select a collection of vertices <span class="math inline">\(F_p\)</span> such that our weighted-distances are minimized, what exactly does this mean mathematically? And what portion of the objective function will serve to establish this meaning?
</p>
<p>
In order to answer these questions above, we must establish two binary variables: first, we need to define a variable that determines whether or not some vertex <span class="math inline">\(v_{\mathscr f_z}\)</span> in our selection site is to be a facility location or not; and second, we must create a variable that indicates, given a particular vertex <span class="math inline">\(v_i \in V\)</span> and any facility <span class="math inline">\(\mathscr f_z \in F_z\)</span>, whether or not the given vertex is served by the given facility.
</p>
<p>
By this construction, our first variable will be single-indexed, whereas our second variable will be double-indexed. We will denote the former variable by <span class="math inline">\(x_i\)</span> and the latter variable by <span class="math inline">\(y_{iz}\)</span>; clearly, it must be so that <span class="math inline">\(x_z,y_{iz} \in [0,1]\)</span>. For now, we will simply keep these variables in mind: we will establish their proper contribution to the linear programming model as well as the domain of their subscripts later on.
</p>
<p>
Let us consider just <span class="math inline">\(\Gamma (F_p)\)</span> alone: we have that our objective function is given by <span class="math display">\[\Gamma(F_p)=\sum_{\mathscr f_z \in F_p} \gamma(\mathscr f_z) +\sum_{v_i \in V} \psi_{F_p} (v_i)\]</span> We will now proceed by back-substituting our notation and mappings defined above in order to formulate the objective function in terms of given quantities. Because our next logical step is to substitute <span class="math display">\[\psi_{F_p} (v_i) \to w_{v_i} \cdot \delta (v_i,F_p)\]</span> followed by <span class="math display">\[\delta (v_i,F_p) \to \min_{\mathscr f_z \in F_p} \delta (v_i,\mathscr f_z)\]</span> we must move to formulate the minimum distance between any vertex in <span class="math inline">\(V\)</span> and any facility in the potential median set in terms of given quantities.
</p>
<p>
Two possibilities arise: for the first case, suppose the vertex in question is an element of the median set; that is, <span class="math inline">\(v_i \in F_p\)</span>. It is clear that this immediately implies <span class="math display">\[\delta (v_i,F_p) = 0\]</span>
</p>
<p>
For all other cases, we suppose that <span class="math inline">\(v_i \notin F_p\)</span>. Then, <span class="math inline">\(\forall\ \mathscr f_z \in F_p\)</span>, because <span class="math inline">\(T\)</span> is connected, there exists some set <span class="math inline">\(K \subset V\)</span> such that every element <span class="math inline">\(v_{k_r} \neq v_i \text{ and } v_{k_r} \neq \mathscr f_z\)</span> in <span class="math inline">\(K\)</span> lies on a path connecting <span class="math inline">\(v_i\)</span> to <span class="math inline">\(\mathscr f_z\)</span>; furthermore, because <span class="math inline">\(T\)</span> is acyclic, this path is <il>the</il> unique path connecting <span class="math inline">\(v_i\)</span> and <span class="math inline">\(\mathscr f_z\)</span>. Before proceeding, let the mapping <span class="math inline">\(\phi: (v_i, \mathscr f_z) \mapsto K\)</span> formally define <span class="math inline">\(K\)</span> for a given <span class="math inline">\((v_i,\mathscr f_z)\)</span> when the vertex and facility in question are ambiguous.
</p>
<p>
Let us denote the <span class="math inline">\(q\)</span> elements <span class="math inline">\(v_{k_r} \in K\)</span> to be such that <span class="math display">\[v_{k_q} = \mathscr f_z \text{ and } \forall\ v_{k_r}\ |\ r = 1,2,\ldots,q-1,\  \exists\ e_{v_{k_r}} \in E\ |\ e_{v_{k_r}} = (v_{k_r},v_{k_{{r+1}}})\]</span> Hence, each subset of vertices <span class="math inline">\(K\)</span> of <span class="math inline">\(V\)</span> defined in the above way induces a subset of edges <span class="math inline">\(\epsilon =(e_{v_{k_1}},e_{v_{k_2}},\ldots,e_{v_{k_{q-1}}}) \subset E\)</span>. As before, we define the mapping <span class="math inline">\(\Phi: K \mapsto \epsilon\)</span> to formally define <span class="math inline">\(\epsilon\)</span> for a given <span class="math inline">\(K\)</span> for a given <span class="math inline">\((v_i,\mathscr f_z)\)</span> by <span class="math display">\[\epsilon = \Phi (K) = (\Phi \circ \phi)(v_i,\mathscr f_z)\]</span> which is composed of <span class="math inline">\(q-1\)</span> elements <span class="math display">\[\epsilon_r = \Phi_r (k) = (\Phi \circ \phi)_r (v_i,\mathscr f_z)\]</span> We define one final mapping before proceeding: <span class="math inline">\(\varepsilon: (v_i,\mathscr f_z,r) \mapsto \epsilon\)</span> as <span class="math display">\[\varepsilon_r (v_i,\mathscr f_z) = (\Phi \circ \phi)_r (v_i,\mathscr f_z)= \epsilon_r\]</span> whenever <span class="math inline">\((v_i,\mathscr f_z)\)</span> is arbitrary and unambiguous.
</p>
<p>
Recall that the set <span class="math inline">\(A\)</span> is defined such that <span class="math inline">\(\forall\ a_{e_k} \in A_E,\ \exists \text{ corresponding } e_k \in E\)</span>. Hence, being careful about our notation, <span class="math inline">\(\forall\ \epsilon_r \in \epsilon \subset E,\ \exists \text{ corresponding } a_{\epsilon_r} \in A_{\epsilon} \subset A_E\)</span>. Thus, it follows that the subset <span class="math inline">\(A_{\epsilon} \subset A_E\)</span> represents the distances between each adjacent node within the set <span class="math inline">\(K \in V\)</span>, <span class="math inline">\(\forall\ v_i \in V\)</span> and <span class="math inline">\(\forall\ \mathscr f_z \in F_p\)</span>
</p>
<p>
Hence, the distance between arbitrary vertex <span class="math inline">\(v_i \in V\)</span> and arbitrary potential facility location <span class="math inline">\(\mathscr f_z \in F_p\)</span> is <span class="math display">\[\delta (v_i,\mathscr f_z) = \sum_{r=1}^{q-1} a_{\epsilon_r} = \sum_{r=1}^{q-1} \lVert \varepsilon_r (v_i,\mathscr f_z) \rVert = \sum_{r=1}^{q-1} \lVert \epsilon_r \rVert = \sum_{r=1}^{q-1} \lVert v_{\epsilon_r} - v_{\epsilon_r}&#39;\rVert\]</span> leading to <span class="math display">\[\psi_{F_p} (v_i) = w_{v_i} \cdot \delta (v_i,F_p) = w_{v_i} \cdot \min_{\mathscr f_z \in F_p} \delta (v_i,\mathscr f_z) = w_{v_i} \cdot \min_{\mathscr f_z \in F_p} \sum_{r=1}^{q-1} \lVert v_{\epsilon_r} - v_{\epsilon_r}&#39;\rVert = w_{v_i} \cdot \min_{\mathscr f_z \in F_p} \sum_{r=1}^{q-1} \lVert v_{\varepsilon_r (v_i,\mathscr f_z)} - v_{\varepsilon_r (v_i,\mathscr f_z)}&#39;\rVert\]</span> Satisfied with our notation, we will from here on out write <span class="math inline">\(\lVert v_{\varepsilon_r (v_i,\mathscr f_z)} - v_{\varepsilon_r (v_i,\mathscr f_z)}&#39;\rVert\)</span> as <span class="math inline">\(a_{\varepsilon_r (v_i,\mathscr f_z)}\)</span> and take the notational convention that <span class="math inline">\(a_{\epsilon_r} \gt 0\)</span>.Thus, <span class="math display">\[\Gamma(F_p)=\sum_{\mathscr f_z \in F_p} \gamma(\mathscr f_z) +\sum_{v_i \in V} \psi_{F_p} (v_i) = \sum_{\mathscr f_z \in F_p} \gamma (\mathscr f_z) + \sum_{v_i \in V} w_{v_i} \cdot \min_{\mathscr f_z \in F_p} \sum_{r=1}^{q-1} a_{\varepsilon_r (v_i,\mathscr f_z)}\]</span>
</p>
<p>
At this point, we will introduce into the objective function one of the variables we defined earlier, <span class="math inline">\(y_{iz}\)</span>. We will do this in order to make precise what is meant by “<span class="math inline">\(\min_{\mathscr f_z \in F_p}\)</span>”. Let <span class="math inline">\(i = 1, 2, \ldots, n\)</span> denote a given vertex <span class="math inline">\(v_i \in V\)</span> and let <span class="math inline">\(z = 1,2,\ldots,m\ |\ m \le n\)</span> denote a given vertex <span class="math inline">\(v_{\mathscr f_z} \in V\)</span> from a subset of vertices <span class="math inline">\(V|_{F_p} \subseteq V\)</span> from which candidate facility locations may be selected; we will use the convention <span class="math inline">\(v_z \in V|_{F_p}\)</span> equivalently with <span class="math inline">\(v_{\mathscr f_z} \in V\)</span>. We define this by <span class="math display">\[y_{iz} = 1 \text{ if } v_i \text{ served by } \mathscr f_z, 0 \text{ o.w.}\]</span> We also now define <span class="math inline">\(x_z\)</span> to establish exactly how and to what the assignment of <span class="math inline">\(F_p\)</span> involves by: <span class="math display">\[x_z = 1 \text{ if } v_z \in V|_{F_p} \text{ is to be a facility location ition in the potential median set}, 0 \text{ o.w. }\]</span>
</p>
<p>
Using these variables, we can now replace <span class="math inline">\(\min_{\mathscr f_z \in F_P}\)</span> by <span class="math inline">\(\sum_{z=1}^m y_{iz}\)</span> and replace <span class="math inline">\(\sum_{\mathscr f_z \in F_P}\)</span> with <span class="math inline">\(\sum_{z=1}^m x_z\)</span><sup><a href="section3">[iii]</a></sup>, which allows us to use linear programming algorithms to solve the objective function. Our objective function is now <span class="math display">\[\Gamma_{iz}= \sum_{z=1}^m x_z \cdot \gamma (\mathscr f_z) + \sum_{i=1}^n w_{v_i} \cdot \sum_{z=1}^m y_{iz} \sum_{r=1}^{q-1} a_{\varepsilon_r (v_i,\mathscr f_z)}\]</span> We can then distribute <span class="math inline">\(\sum_{i=1}^n w_{v_i}\)</span> into the sum <span class="math inline">\(\sum_{z=1}^{m}\)</span>, leading to <span class="math display">\[\Gamma_{iz} = \sum_{z=1}^m x_{z}\cdot \gamma (\mathscr f_z) + \sum_{z=1}^m\ \Bigl( \sum_{i=1}^n w_{v_i} y_{iz} \cdot \sum_{r=1}^{q-1} a_{\varepsilon_r (v_i,\mathscr f_z)} \Bigr)\]</span>
</p>
<p>
Now, WLOG, because <span class="math display">\[y_{iz} = 1 \implies x_z = 1\]</span> we may multiply the quantity in the large parenthesis of the second term by x_z and keep equality with our previous formula for our objective function; that is, <span class="math display">\[\Gamma_{iz} = \sum_{z=1}^m x_{z} \cdot \gamma (\mathscr f_z) + \sum_{z=1}^m\ x_z \cdot \Bigl( \sum_{i=1}^n w_{v_i} y_{iz} \sum_{r=1}^{q-1} a_{\varepsilon_r (v_i,\mathscr f_z)} \Bigr)\]</span> This allows us to distribute <span class="math inline">\(\sum_{z=1}^m x_z\)</span> out of both quantities, leading to <span class="math display">\[\sum_{z=1}^m x_z \cdot \Bigl(\ \gamma (\mathscr f_z) + \sum_{i=1}^n w_{v_i} y_{iz} \sum_{r=1}^{q-1} a_{\varepsilon_r (v_i,\mathscr f_z)}\ \Bigr) = \sum_{z=1}^m x_z \cdot \biggl(\ \sum_{i=1}^n \Bigl(\ \gamma (\mathscr f_z) \cdot n^{-1} +  w_{v_i} y_{iz} \sum_{r=1}^{q-1} a_{\varepsilon_r (v_i,\mathscr f_z)}\ \Bigr)\ \biggr)\]</span>
</p>
<p>
Finally, if we denote by <span class="math inline">\(c_z\)</span> the value of the quantity within the largest parentheses at a given value <span class="math inline">\(z = 1, 2, \ldots, m\)</span>, we can write the objective function as <span class="math display">\[\Gamma_z = \sum_{z=1}^m x_z c_z\]</span> Because <span class="math inline">\(c_z\)</span> is linear in terms of <span class="math inline">\(z\)</span><sup><a href="#section4">[iv]</a></sup>, we have established that the objective function we have developed for the p-median problem fits the form of <span class="math inline">\(\eqref{eq1}\)</span>, as desired.
</p>
<p>
A quick review of our notation used thus far:
<ul style="line-height: 1.7;">
<li>
<span class="math inline">\(G=(V,E)\)</span> is the p-median problem formulated as a graph with vertices <span class="math inline">\(V\)</span> representing demands nodes and edges <span class="math inline">\(E\)</span> representing paths between adjacent demand nodes
</li>
<li>
<span class="math inline">\(T=G\)</span> is the tree <span class="math inline">\(T\)</span> representing our topological location model
</li>
<li>
<span class="math inline">\(W_V\)</span> is the set of weights of <span class="math inline">\(V\)</span> where <span class="math inline">\(\forall\ v_i \in V,\ \exists\ w_{v_i} \in W_V\)</span> representing the weight of demand at node <span class="math inline">\(v_i\)</span>
</li>
<li>
<span class="math inline">\(A_E\)</span> is the set of norms of <span class="math inline">\(E\)</span> (with respect to the tree-metric) where <span class="math inline">\(\forall\ e_k \in E,\ \exists\ a_{e_k} \in A_E\)</span> representing the distance between the adjacent nodes <span class="math inline">\(v_{e_k}\)</span> and <span class="math inline">\(v_{e_k}&#39;\)</span> attached to edge <span class="math inline">\(e_k\)</span>
</li>
<li>
<span class="math inline">\(F_p \subset V\)</span> is some arbitrary collection of <span class="math inline">\(p\)</span> nodes selected from possible demand nodes to allocate as potential facility locations; we call this the potential median set
</li>
<li>
<span class="math inline">\(\delta (v_i,v_j)\)</span> represents the distance between any two (possibly non-adjacent) arbitrary vertices <span class="math inline">\(v_i,v_j \in V\)</span> <b>as a function of any two vertices in <span class="math inline">\(V\)</span></b>; additionally, <span class="math inline">\(\delta (v_i,F_p)\)</span> is defined to be the minimum distance between vertex <span class="math inline">\(v_i\)</span> and any facility within the potential median set
</li>
<li>
<span class="math inline">\(\psi_{F_p} (v_i) = w_{v_i} \cdot \delta (v_i,F_p)\)</span> represents the minimum weighted distance between vertex <span class="math inline">\(v_i\)</span> and any facility within the potential median set <b>as a function of potential median sets</b>
</li>
<li>
<span class="math inline">\(\gamma (f_z)\)</span> represents the potential cost of locating a facility at the location <span class="math inline">\(f_z\)</span> in the potential median set <b>as a function of facilities within a given potential median set</b>
</li>
<li>
<span class="math inline">\(\Gamma (F_p)\)</span> represents the total cost incurred given any potential median set <b>as a function of potential median sets</b>
</li>
<li>
<span class="math inline">\(\mathscr F_p\)</span> is the set of <span class="math inline">\(p\)</span> nodes selected from possible demand nodes that represents the minimized total cost incurred given a potential median set; it is the <b>minimal p-median set</b>: the solution to the p-median problem
</li>
<li>
<span class="math inline">\(\phi: (v_i, \mathscr f_z) \mapsto K\)</span> represents the subset of vertices (in sequential order) spanned going from a given demand node <span class="math inline">\(v_i \in V\)</span> to any facility location <span class="math inline">\(\mathscr f_z\)</span> in the potential median set, <span class="math inline">\(F_p\)</span>; we denote each vertex in <span class="math inline">\(K\)</span> by <span class="math inline">\(v_{\mathscr f_q}\)</span>
</li>
<li>
<span class="math inline">\(\varepsilon: (v_i,\mathscr f_z,r) \mapsto \epsilon\)</span> represents the set of edges <span class="math inline">\(\varepsilon_r (v_i,\mathscr f_z) = (\Phi \circ \phi)_r (v_i,\mathscr f_z)= \epsilon_r\)</span> (in sequential order) spanned by <span class="math inline">\(K\)</span> going from a given demand node <span class="math inline">\(v_i \in V\)</span> to any facility location <span class="math inline">\(\mathscr f_z\)</span> in the potential median set, <span class="math inline">\(F_p\)</span>
</li>
<li>
<span class="math inline">\(y_{iz}\)</span> indicates whether or not vertex <span class="math inline">\(v_i \in V\)</span> is served by facility <span class="math inline">\(\mathscr f_z \in F_p\)</span>
</li>
<li>
<span class="math inline">\(x_z\)</span> indicates whether or not candidate facility <span class="math inline">\(v_z \in V|_{F_p}\)</span> lies in the potential median set <span class="math inline">\(F_p\)</span>
</ul>
</p>
</div>
<div id="formulating-the-constraint-equations" class="section level2">
<h2>Formulating the Constraint Equations</h2>
<p>
In order to finish establishing the p-median problem in the form of the general programming problem, we need a set of constraint equations that must be satisfied by the objective function. These constraint equations can be formulated by specifying the terms of the model in its physical specificities/limitations.
</p>
<p>
We begin by establishing constraints with respect to our two introduce binary variables, <span class="math inline">\(x_z\)</span> and <span class="math inline">\(y_{iz}\)</span>. By definition, both of these variables may only take on one of two values, <span class="math inline">\(1\)</span> or <span class="math inline">\(0\)</span>. Hence, our first two contraints are of the form <span class="math display">\[x_z \in \{0,1\},\ \forall\ z = 1,2,\ldots,m\]</span> and <span class="math display">\[y_{iz} \in \{0,1\},\ \forall\ i = 1,2,\ldots,n \text{ and } \forall\ z = 1,2,\ldots,m\]</span> We see that these contraints satisfy <span class="math inline">\(\eqref{eq3}\)</span>.
</p>
<p>
Next, we consider contraints based on what exactly it is that we are trying to do for each of these two variables. For the candidate facility variable, <span class="math inline">\(x_z\)</span>, we desire to select <span class="math inline">\(p\)</span> nodes out of the set <span class="math inline">\(V|_{F_p} \subseteq V\)</span>: no more, no less; hence, our next contraint is of the form <span class="math display">\[\sum_{z=1}^m x_z = p\]</span> With respect to the facility assignment variable, <span class="math inline">\(y_{iz}\)</span>, we desire to assign each vertex <span class="math inline">\(v_i \in V\)</span> one and only one facility, <span class="math inline">\(\mathscr f_z \in F_p\)</span>; hence, we have established a fourth constraint to be of the form <span class="math display">\[\sum_{z=1}^m y_{iz} = 1,\ \forall\ z=1,2,\ldots,m\]</span> We see that these contraints satisfy <span class="math inline">\(\eqref{eq2}\)</span>.
</p>
<p>
Considering the constraint <span class="math inline">\(\eqref{eq2}\)</span> of the general linear programming problem in terms of multiple-indexed variables, we should also establish constraints of any linear combination of the single-indexed and multi-indexed variables. Thus, we must consider interactions between our two binary variables. Because <span class="math inline">\(x_z\)</span> is assigned independently from <span class="math inline">\(y_{iz}\)</span>, no restriction is applied onto <span class="math inline">\(x_z\)</span> from <span class="math inline">\(y_{iz}\)</span>. However, when assigning a facility <span class="math inline">\(\mathscr f_z\)</span> for a given node <span class="math inline">\(v_i\)</span>, we must be sure that the precise vertex corresponding to the given <span class="math inline">\(z\)</span> in <span class="math inline">\(\{1,2,\ldots,m\}\)</span> (that is, <span class="math inline">\(v_{\mathscr f_z} \in V\)</span>) has <it>actually</it> been assigned to the potential median set<sup><a href="#section3">[iii]</a></sup>. We make this mathematically stated by observing that from the two values each binary variable can take on, four possible states can occur:
<ol>
<li>
<span class="math inline">\(y_{iz} = 0\)</span> and <span class="math inline">\(x_z = 0\)</span>; node <span class="math inline">\(v_i\)</span> is not assigned to facility <span class="math inline">\(\mathscr f_z\)</span>, and <span class="math inline">\(v_{\mathscr f_z}\)</span> is not assigned to the potential median set <span class="math inline">\(\implies\)</span> <b>no problem</b>
</li>
<li>
<span class="math inline">\(y_{iz} = 0\)</span> and <span class="math inline">\(x_z = 1\)</span>; node <span class="math inline">\(v_i\)</span> is not assigned to facility <span class="math inline">\(\mathscr f_z\)</span>, and <span class="math inline">\(v_{\mathscr f_z}\)</span> is assigned to the potential median set <span class="math inline">\(\implies\)</span> <b>no problem</b>
</li>
<li>
<span class="math inline">\(y_{iz} = 1\)</span> and <span class="math inline">\(x_z = 0\)</span>; node <span class="math inline">\(v_i\)</span> is assigned to facility <span class="math inline">\(\mathscr f_z\)</span>, and <span class="math inline">\(v_{\mathscr f_z}\)</span> is not assigned to the potential median set <span class="math inline">\(\implies\)</span> <b>problem</b>
</li>
<li>
<span class="math inline">\(y_{iz} = 1\)</span> and <span class="math inline">\(x_z = 1\)</span>; node <span class="math inline">\(v_i\)</span> is assigned to facility <span class="math inline">\(\mathscr f_z\)</span>, and <span class="math inline">\(v_{\mathscr f_z}\)</span> is also assigned to the potential median set <span class="math inline">\(\implies\)</span> <b>no problem</b>
</li>
</ol>
Hence, our contraint must be of the form such that state (3.) above does not not occur. From inspection, we observe that <span class="math inline">\(y_{iz} - x_z \le 0\)</span> for all cases except for the problematic case. Thus, we can establish a constraint that satisfies the above restriction of the form <span class="math display">\[y_{iz} - x_z \le 0,\ \forall\ i=1,2,\ldots,n\ , \text{ and } \forall z=1,2,\ldots,m\]</span> We see that this constraint satisfies <span class="math inline">\(\eqref{eq2}\)</span> in the context of multiple variables.
</p>
<p>
For the constraint <span class="math inline">\(\eqref{eq4}\)</span>, we will make restrictions on all constants involved in <span class="math inline">\(\eqref{eq1}\)</span> and <span class="math inline">\(\eqref{eq2}\)</span>. Clearly, <span class="math inline">\(c_z \in \Bbb R\)</span>. Next, by denoting <span class="math inline">\(\alpha_{iz} = 1\)</span>, <span class="math inline">\(\beta_z = p\)</span>, <span class="math inline">\(\eta_{iz} = 1\)</span>, and <span class="math inline">\(\mu_{iz} =1\)</span> we can rewrite <span class="math display">\[\sum_{z=1}^m x_z = p \text{ as } \sum_{z=1}^m \alpha_{iz} x_z = \beta_z,\ \forall\ z=1,2,\ldots,m\]</span> and <span class="math display">\[\sum_{z=1}^m y_{iz} = 1,\ \forall\ z=1,2,\ldots,m \text{ as } \sum_{z=1}^m \eta_{iz} y_{iz} = \mu_{iz},\ \forall\ z=1,2,\ldots,m\]</span> where <span class="math inline">\(\alpha_{iz}, \eta_{iz} \in \Bbb R\)</span> and <span class="math inline">\(\beta_z, \mu_{iz} \ge 0\)</span>. Finally, we have already established that <span class="math inline">\(m \lt n\)</span>. Thus, we have established that <span class="math inline">\(\eqref{eq4}\)</span> is satisfied.
</p>
<p>
We can finally write the p-median problem in terms of the general linear programming problem:
<blockquote>
Minimize <span class="math display">\[\Gamma_z = \sum_{z=1}^m x_z c_z \tag{1}\]</span> subject to <span class="math display">\[ \sum_{z=1}^m \alpha_{iz} x_z = \beta_z \text{ and } \sum_{z=1}^m \eta_{iz} y_{iz} = \mu_{iz},\ \forall\ z=1,2,\ldots,m \tag{2}\]</span> and <span class="math display">\[x_z \in \{0,1\},\ \forall\ z = 1,2,\ldots,m \text{ and } y_{iz} \in \{0,1\},\ \forall\ i = 1,2,\ldots,n \text{ and } \forall\ z = 1,2,\ldots,m \tag{3}\]</span> where <span class="math display">\[\alpha_{iz}, \eta_{iz}, c_z \in \Bbb R \text{, } \beta_z, \mu_{iz} \ge 0 \text{, and } m\lt n \tag{4}\]</span>
</blockquote>
</p>
</div>
</div>
<div id="finding-a-solution-to-a-linear-programming-problem" class="section level1">
<h1>Finding a Solution to a Linear Programming Problem</h1>
</div>
<div id="references" class="section level1">
<h1>References:</h1>
<div class="reference">
<p id="section1" style="margin-bottom: 7px; line-height=1">
[i] “(PDF) A New Template for Solving p-Median Problems for Trees in Sub-Quadratic Time.” ResearchGate. Accessed April 22, 2019. <cite><a href="https://www.researchgate.net/publication/220770539_A_New_Template_for_Solving_p-Median_Problems_for_Trees_in_Sub-quadratic_Time" class="uri">https://www.researchgate.net/publication/220770539_A_New_Template_for_Solving_p-Median_Problems_for_Trees_in_Sub-quadratic_Time</a></cite>.
</p>
<p id="section2" style="margin-bottom: 7px; line-height=1;">
[ii] For simplicity, by the term “tree-metric distance” here, we are meaning to say that the distance between any two nodes of <span class="math inline">\(\normalsize T\)</span> is given by the “tree-path” distance described by the topology of the tree itself.
</p>
<p id="section3" style="margin-bottom: 7px; line-height=1;">
[iii] There is a bit of particular nuance with respect to mathematical rigor that is glossed over here: because <span class="math inline">\(\normalsize \min_{\mathscr f_z \in F_p}\)</span> is indexed for all <span class="math inline">\(\normalsize \mathscr f_z \in F_P\)</span> where <span class="math inline">\(\normalsize \scriptsize F_p = (\mathscr f_z\ |\ z = 1,2,\ldots,p\ ,\ p\lt n )\)</span> contains <span class="math inline">\(\normalsize p\)</span> terms, <span class="math inline">\(\normalsize \mathscr f_z\)</span>, whereas <span class="math inline">\(\normalsize \sum_{z=1}^m y_{iz}\)</span> is indexed for all <span class="math inline">\(\normalsize v_{\mathscr f_z} \in V \iff v_z \in V|_{F_p}\)</span> where <span class="math inline">\(\normalsize V|_{F_p} = (v_z\ |\ z=1,2,\ldots,m\ ,\ m \gt p\ \land\ m \le n\)</span> contains <span class="math inline">\(\normalsize m\)</span> terms, both <b>using the same index <span class="math inline">\(\normalsize \mathscr f_z\)</span> when switching from <span class="math inline">\(\normalsize \min_{\mathscr f_z \in F_p}\)</span> to <span class="math inline">\(\normalsize \sum_{z=1}^m y_{iz}\)</span></b> as well as <b>considering the index to switch from <span class="math inline">\(\normalsize p\)</span> terms to <span class="math inline">\(\normalsize m\)</span> terms</b> are an abuse of mathematical notation. However, because the additional term <span class="math inline">\(\normalsize y_{i{z_0}},\ \forall\ i=1,2,\ldots,n\)</span> evaluated at some <span class="math inline">\(\normalsize z_0 \in (1,2,\ldots,m)\)</span> is equal to zero whenever it so happens that the term <span class="math inline">\(\normalsize \mathscr f_{z_0} \notin F_p\)</span> but is equal to one otherwise, the result is the same; for the sake of brevity, then, this mathematical abuse of notation is used for this paper.
</p>
<p id="section4" style="margin-bottom: 7px; line-height=1;">
[iv] More specifically, <span class="math inline">\(\normalsize c_z\)</span> is linear in terms of <span class="math inline">\(\normalsize z\)</span> <it>with respect to</it> <span class="math inline">\(\normalsize i\)</span>. However, because <span class="math inline">\(\normalsize \gamma (\mathscr f_z) \cdot n^{-1} + w_{v_i} y_{iz} \sum_{r=1}^{q-1} a_{\varepsilon_r (v_i,\mathscr f_z)}\)</span> is linear in terms of <span class="math inline">\(\normalsize i,\ \forall\ i=1,2,\ldots,n\)</span>, the linearity of the objective function still follows accordingly.
</p>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "Travis_p-median_Problem_files/mathjax-local/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
