<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>The p-median Problem</title>

<script src="Travis_p-median_Problem_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="Travis_p-median_Problem_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="Travis_p-median_Problem_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="Travis_p-median_Problem_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="Travis_p-median_Problem_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="Travis_p-median_Problem_files/navigation-1.1/tabsets.js"></script>
<link href="Travis_p-median_Problem_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="Travis_p-median_Problem_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>



<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="fluid-row" id="header">



<h1 class="title toc-ignore">The p-median Problem</h1>

</div>


<h1>
Statement of the Problem
</h1>
<p>The p-median problem is an application of linear optimization approaches with respect to a graph. Specifically, it is a facility-location model with the purpose of locating <span class="math inline">\(p\)</span> facilities (hereafter referred to as vertices or nodes) to minimize a constraint equation based on weighted average distances between demand nodes and selection location nodes.</p>
<p>
Stated more formally, given some graph <span class="math inline">\(G=(V,E)\)</span> where <span class="math display">\[V=(v_1,\ldots,v_n: n \in \Bbb N)\]</span> is a set of nodes of <span class="math inline">\(G\)</span>, each representing a demand weight, and where <span class="math display">\[E=(e_1,\ldots,e_m: m \in \Bbb N)\]</span> is a set of connected nodes of <span class="math inline">\(G\)</span>, the p-median problem seeks to find any number <span class="math inline">\(p\)</span> vertices such that the sum of the weighted distances from each vertex in <span class="math inline">\(G\)</span> to the closest facility is minimized. The lengths between each vertex and each facility is calculated by taking the absolute value of each member of <span class="math inline">\(E\)</span> that represents a successive path connection of nodes in between the two and computing their sum.
</p>
<p>
In this paper, we will be discussing how exactly this calculation is performed. Three sections will be covered:
<ul>
<li>
Rectifying the Issue of Computational Complexity
</li>
<li>
Setting up the p-median Problem as a Linear Programming Problem
</li>
<li>
Finding a Solution to a Linear Programming Problem
</li>
</ul>
</p>
<p><br></p>
<h1>
Rectifying the Issue of Computational Complexity
</h1>
<p>Unfortunately, when attempting to perform optimization calculations for this problem using a general graph, the computation time is <span class="math inline">\(\mathcal N \mathcal P\)</span>-hard. We can rectify this however by formulating the problem using a mathematical tree.</p>
<p>
Given some graph <span class="math inline">\(G=(V,E)\)</span> where <span class="math display">\[V=(v_1,\ldots,v_n: n \in \Bbb N)\]</span> is a set of nodes of <span class="math inline">\(G\)</span>, and where <span class="math display">\[E=(e_1,\ldots,e_m: m \in \Bbb N)\]</span> is a set of connected nodes of <span class="math inline">\(G\)</span>, we call the graph <span class="math inline">\(T=G\)</span> a <b>tree</b> if it is undirected, connected, and contains no cycles. From the procedures detailed in (Benkoczi et al.)<sup><a href="#section1">[i]</a></sup>, if <span class="math inline">\(T\)</span> is a both rooted and binary tree, then an <span class="math inline">\(O(nlog^{p+2}n)\)</span> algorithm exists; thus, a solution to the p-median problem on <span class="math inline">\(T\)</span> can be computed in polynomial time.
</p>
<p>
If <span class="math inline">\(T\)</span> is not rooted, then it can be made to be so by arbitrarily selecting a vertex to designate as its root. If <span class="math inline">\(T\)</span> is not binary, then <span class="math inline">\(T\)</span> may be made to be binary by adding a linear number of vertices and edges to that set. Because it follows that any object that is composed of a linear function of objects that can be solved in polynomial time is itself solvable in polynomial time, then it follows that a tree <span class="math inline">\(T\)</span> which is neither rooted nor binary can also be solved in polynomial time.
</p>
<p>
Thus, because the graph <span class="math inline">\(G\)</span> for the p-median problem can be formulated as the tree <span class="math inline">\(T=G\)</span>, it follows that we can calculate a solution for the p-median problem in polynomial time.
</p>
<p><br></p>
<h1>
Setting up the p-median Problem as a Linear Programming Problem
</h1>
<p>
Now that we have established that we can find a solution to the p-median problem in polynomial time by setting up the problem as a tree, we desire to formulate the p-median problem as a linear programming problem. The form for the general linear programming problem is as follows:
<blockquote>
Minimize <span class="math display">\[f(\mathbf X) = \sum_{i=1}^n c_i x_i \tag{1}\label{eq1}\]</span> subject to <span class="math display">\[\sum_{i=1}^n a_{ij} x_i = b_j \forall \ j=1,2,\ldots,m \tag{2}\label{eq2}\]</span> and <span class="math display">\[x_i\ge 0, \forall \ i=1,2,\ldots,n \tag{3}\label{eq3}\]</span> where <span class="math display">\[a_{ij},c_i \in \Bbb R \text{, } b_j \ge 0 \text{, and } m\lt n \tag{4}\label{eq4}\]</span>
</blockquote>
<p>
We will first find the total cost as a function of any given collection of <span class="math inline">\(p\)</span> vertices from our set of nodes; we will refer to this function as the <b>objective function</b>. Once this is done, we will use this objective function to formulate the p-median problem in the form of the general linear programming problem. We divide these two procedures into two subsections.
</p>
<p><br></p>
<h2>
Formulating the Objective Function
</h2>
<p>Let <span class="math inline">\(T=G\)</span> be as before, and let <span class="math display">\[F_p=(\mathscr f_1,\dots,\mathscr f_p:p\leq n \in \Bbb N)\]</span> be a collection of some <span class="math inline">\(p\)</span> vertices in <span class="math inline">\(T\)</span> which represent a potential facility-location set (hereafter referred to as <i>median set</i>) for <span class="math inline">\(T\)</span>. Let <span class="math display">\[W=(w_1,\ldots,w_n:n \in \Bbb N)\]</span> be such that <span class="math inline">\(w_i\)</span> represents the weight for vertex <span class="math inline">\(v_i \in V\)</span>; similarly, define <span class="math display">\[A=(a_1,\ldots,a_m:m \in \Bbb N)\]</span> to be the (tree-metric) distance<sup><a href="#section2">[ii]</a></sup> between adjacent vertices such that, if <span class="math display">\[e_k=(e_{k_1},e_{k_2})\]</span> where <span class="math inline">\(e_{k_1},e_{k_2} \in V\)</span>, then <span class="math display">\[a_k=\lVert e_k\rVert=\lVert e_{k_1} - e_{k_2} \rVert,\forall \ e_k \in E\]</span></p>
<p>
Let the distance between any two arbitrary vertices <span class="math inline">\(v_i,v_j \in V\)</span> be defined as the mapping <span class="math inline">\(\delta:(v_i,v_j) \mapsto \delta(v_i,v_j)\)</span>, and then define the mapping <span class="math inline">\(\psi:v_i \mapsto \psi(v_i)\)</span> to be the minimum weighted distance between vertex <span class="math inline">\(v_i\)</span> and any facility within the potential median set; that is, <span class="math display">\[\psi(v_i)=w_i \cdot\min_{\mathscr f_z \in F_p} \delta (v_i,\mathscr f_z)\]</span> Finally, let the potential cost of locating a facility at the location <span class="math inline">\(\mathscr f_z\)</span> be defined as the mapping <span class="math inline">\(\gamma:\mathscr f_z \mapsto \gamma(\mathscr f_z)\)</span>.
</p>
<p>
We are now ready to formulate our objective function for any given potential median set: we define the mapping <span class="math inline">\(\Gamma: F_p \mapsto \Gamma(F_p)\)</span> by <span class="math display">\[\Gamma(F_p)=\sum_{\mathscr f_z \in F_p} \gamma(\mathscr f_z) +\sum_{v_i \in V} \psi(v_i)\]</span> to be the objective function for any given potential median set <span class="math inline">\(F_p \subseteq V\)</span>.
</p>
<p><br></p>
<h2>
Creating the General Linear Programming Problem
</h2>
<p>Because we wish to select from any arbitrary potential median set the one for which the objective function is minimized, our goal in solving the p-median problem is to find the median set <span class="math inline">\(\mathscr F_p\)</span> such that <span class="math display">\[\mathscr F_p = \min_{F_p \subseteq V} \Gamma (F_p)\]</span> We will show that, with a few adjustments in terminology and symbology, this <span class="math inline">\(\mathscr F_p\)</span> fits the form of <span class="math inline">\(\eqref{eq1}\)</span>.</p>
<h3>
Rearranging the Objective Function
</h3>
<p>
Looking just at <span class="math inline">\(\Gamma (F_p)\)</span> alone, we have that our objective function is equal to <span class="math display">\[\sum_{z=1}^p \gamma (\mathscr f_z) + \sum_{i=1}^n \psi (v_i)\]</span> then, using the fact that <span class="math display">\[\psi (v_i) = w_i \cdot \min_{\mathscr f_z \in F_p} \delta (v_i,\mathscr f_z)\]</span> our objective function can be written as <span class="math display">\[\sum_{z=1}^p \gamma (\mathscr f_z) + \sum_{i=1}^n w_i \cdot \min_{\mathscr f_z \in F_p} \delta (v_i,\mathscr f_z)\]</span>
</p>
To proceed any further, we need to formulate the two-variable function <span class="math inline">\(\delta\)</span> using known quantities given from the problem. For the first case, suppose the vertex in question is an element of the median set; that is, <span class="math inline">\(v_i \in F_p\)</span>. If we now define the notation <span class="math display">\[\delta (v_i, F_p) = \min_{\mathscr f_z \in F_p} \delta (v_i,\mathscr f_z)\]</span> then it follows that <span class="math inline">\(\delta (v_i,F_p) = 0\)</span>.
</p>
<p>
For all other cases, we suppose that <span class="math inline">\(v_i \notin F_p\)</span>. Then, <span class="math inline">\(\forall\ \mathscr f_z \in F_p\)</span> because <span class="math inline">\(T\)</span> is connected, there exists some set <span class="math inline">\(K \subset V\)</span> such that every element <span class="math inline">\(k \neq v_i \text{ and } k \neq \mathscr f_z\)</span> in <span class="math inline">\(K\)</span> lies on a path connecting <span class="math inline">\(v_i\)</span> to <span class="math inline">\(\mathscr f_z\)</span>; furthermore, because <span class="math inline">\(T\)</span> is acyclic, this path is <il>the</il> unique path connecting <span class="math inline">\(v_i\)</span> and <span class="math inline">\(\mathscr f_z\)</span>. Before proceeding, let the mapping <span class="math inline">\(\phi: (v_i, \mathscr f_z) \mapsto K\)</span> formally define <span class="math inline">\(K\)</span> for a given <span class="math inline">\(v_i,\mathscr f_z\)</span> when the vertex and facility in question are ambiguous.
</p>
<p>
Let us denote the <span class="math inline">\(q\)</span> elements <span class="math inline">\(k_q \in K\)</span> to be such that <span class="math display">\[k_q=\mathscr f_z \text{ and } \forall\ k_r\ |\ r = 1,2,\ldots,q-1,\  \exists\ e_{k_r} \in E\ |\ e_{k_r} = (k_r,k_{r+1})\]</span> Hence, each subset of vertices <span class="math inline">\(K\)</span> of <span class="math inline">\(V\)</span> defined in the above way induces a subset of edges <span class="math inline">\((e_{k_1},e_{k_2},\ldots,e_{k_{q-1}}) \subset E\)</span>. As before, we define the mapping <span class="math inline">\(\Phi: K \mapsto \epsilon\)</span> to formally define <span class="math inline">\(\epsilon\)</span> for a given <span class="math inline">\(K\)</span> for a given <span class="math inline">\(v_i,\mathscr f_z\)</span> by <span class="math display">\[\epsilon = \Phi (K) = (\Phi \circ \phi)(v_i,\mathscr f_z)\]</span> which is composed of <span class="math inline">\(q-1\)</span> elements <span class="math display">\[\epsilon_r = \Phi_r (k) = (\Phi \circ \phi)_r (v_i,\mathscr f_z)\]</span> We define one final mapping before proceeding: <span class="math inline">\(\varepsilon: (v_i,\mathscr f_z,r) \mapsto \epsilon\)</span> as <span class="math display">\[\varepsilon_r (v_i,\mathscr f_z) = (\Phi \circ \phi)_r (v_i,\mathscr f_z)= \epsilon_r\]</span>
</p>
<p>
Recall that the set <span class="math inline">\(A\)</span> is defined such that <span class="math inline">\(\forall\ a_k \in A,\ \exists \text{ corresponding } e_k \in E\)</span>. Hence, being careful about our notation, <span class="math inline">\(\forall\ \epsilon_r \in \epsilon \subset E,\ \exists \text{ corresponding } a_{\epsilon_r} \in A_{\epsilon} \subset A\)</span>. Thus, it follows that the subset <span class="math inline">\(A_{\epsilon} \subset A\)</span> represents the distances between each adjacent node within the set <span class="math inline">\(K \in V\)</span>, <span class="math inline">\(\forall\ v_i \in V\)</span> and <span class="math inline">\(\forall\ \mathscr f_z \in F_p\)</span>, hence <span class="math display">\[\delta (v_i,\mathscr f_z) = \sum_{r=1}^{q-1} a_{\epsilon_r}= \sum_{r=1}^{q-1} \varepsilon_r (v_i,\mathscr f_z)\]</span> leading to <span class="math display">\[\psi (v_i) = w_i \cdot \min_{\mathscr f_z \in F_p} \sum_{r=1}^{q-1} \varepsilon_r (v_i,\mathscr f_z)\]</span> and thus <span class="math display">\[\Gamma (F_p) = \sum_{\mathscr f_z \in F_p} \gamma (\mathscr f_z) + \sum_{v_i \in V} w_i \cdot \min_{\mathscr f_z \in F_p} \sum_{r=1}^{q-1} \varepsilon_r (v_i,\mathscr f_z)\]</span>
</p>
<p>
<p>Let <span class="math inline">\(\xi\)</span> denote the sum of all <span class="math inline">\(\varepsilon\)</span> for given <span class="math inline">\(v_i,\mathscr f_z\)</span>: <span class="math display">\[\xi (v_i,\mathscr f_z) = \sum_{r=1}^{q-1} \varepsilon_r (v_i,\mathscr f_z) \]</span> Our objective function has now become <span class="math display">\[\Gamma (F_p) = \sum_{\mathscr f_z \in F_p} \gamma (\mathscr f_z) + \sum_{v_i \in V} w_i \cdot \xi (v_i,\mathscr f_z) \]</span> Finally, because there exists a one-to-one correspondence between <span class="math inline">\(v_i \in V \text{ and } i=1,2,\cdots,n\)</span> as well as between <span class="math inline">\(\mathscr f_z \in F_p \text{ and } z=1,2,\cdots,n\)</span></p>
<p><br></p>
<h1>
References:
</h1>
<p id="section1">
[i] “(PDF) A New Template for Solving p-Median Problems for Trees in Sub-Quadratic Time.” ResearchGate. Accessed April 22, 2019. <cite><a href="https://www.researchgate.net/publication/220770539_A_New_Template_for_Solving_p-Median_Problems_for_Trees_in_Sub-quadratic_Time" class="uri">https://www.researchgate.net/publication/220770539_A_New_Template_for_Solving_p-Median_Problems_for_Trees_in_Sub-quadratic_Time</a></cite>.
</p>
<p id="section2">
<p>[ii] For simplicity, by the term “tree-metric distance” here, we are meaning to say that the distance between any two nodes of <span class="math inline">\(T\)</span> is given by the “tree-path” distance described by the topology of the tree itself.</p>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "Travis_p-median_Problem_files/mathjax-local/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
